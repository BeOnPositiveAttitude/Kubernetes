Перед погружением в Service Mesh и Istio давайте посмотрим на эволюционные изменения в проектировании ПО за последние два десятилетия.

В 2000-х годах разработка ПО стала сильно ориентированной на процесс и медленной. Для некоторых индустрий, например для оборонки и авиации, это занимало почти 20 лет. Существовал огромный временной разрыв между необходимостью возникновения ПО и его окончательной доставкой. Бизнес успевал измениться еще до того, пока программные продукты были реализованы. Многие проекты были прекращены еще до их завершения. Было потрачено очень много денег. И владельцы бизнеса и IT-специалисты были расстроены.

В 2001-м году 17 независимых специалистов по программному обеспечению собрались вместе и опубликовали Agile манифест. Они рассказали миру, что имеющийся способ создания ПО имеет основные недостатки и нуждается в изменении.

Исходя из имеющегося у них опыта, они решили, что важнее:
- ценить людей и взаимодействие выше процессов и инструментов,
- работающее ПО, чем исчерпывающая документация,
- сотрудничество с клиентами, чем переговоры по контракту,
- реагирование на изменения, чем следование плану.

Основываясь на Agile практике, мы не только больше сотрудничаем с клиентами, но также развиваем наши бизнес-модели и ПО на основе реальных экспериментов.

Когда вы работаете над одним большим приложением, если что-то ломается, то ломается целиком.

Однако, если бы вы меняли небольшие кусочки приложения, то все было бы под контролем. Кусок, над которым вы экспериментируете, может быть затронут, но риск будет меньше, чем прежде.

Так мы начали проектировать приложения все более и более маленькими, чтобы была возможность изолировать риски в процессе экспериментов, а также для более быстрого и частого деплоя.

Гигантские системы, которые мы разрабатывали, становились одной большой проблемой на пути к инновациям и гибкости. Мы должны были взглянуть на традиционную архитектуру ПО и переработать ее.

Термин "монолитный" используется, когда весь функционал приложения необходимо разворачивать одновременно и существует единый подход ко всем отдельным функциональным возможностям в рамках монолитных границ. Все функциональности как правило используют единую кодовую базу и нет четких границ между ними. Эти кусочки тесно связаны. Весь код даже может работать как один процесс. В этой модели обычно используется единая БД для persistance, которая в определенный момент становится "бутылочным горлышком".

Давайте посмотрим как работает "монолит" в реальном приложении. Здесь представлено приложение "Book Info App". Мы будем использовать его в качестве примера в этом курсе. Оно состоит из четырех разных модулей - Details, Reviews, Ratings, Product Page. Это модульное приложение, но все еще монолитное. Все сервисы зависят от определенной версии друг друга. Вам нужно развернуть весь пакет и возможно выполнить несколько скриптов в БД.

<img src="screen1.png" width="400" height="500"><br>

Страница продукта отображает информацию о книгах, обзоры и рейтинги. Все данные приложения приходят из разных модулей. Но эти модули не спроектированы по отдельности и не могут быть масштабированы.

Давайте попробуем понять зависимости модулей и проблемы монолитного приложения "Book Info App". Клиент попадает на страницу продукта.

Страница продукта получает информацию от модулей Reviews и Details.

Сервис Reviews получает количество рейтингов от сервиса Ratings.

Все они написаны на одном и том же языке - Java.

Кроме этих модулей приложение также "заботится" о сетевом взаимодействии, аутентификации, правилах авторизации, мониторинге, логировании, трассировке, каким образом данные передаются между модулями и т.д.

<img src="screen2.png" width="600" height="500"><br>

Время от времени модуль Ratings из-за количества данных испытывает проблемы и это влияет на всю систему.

Невозможно масштабировать только модуль Ratings или убрать его из системы без вмешательства в код и переразвертывания приложения.

Сейчас разрабатывается новый модуль Campaign и под него была сформирована новая команда, которая хочет использовать другой язык при разработке.

Т.к. все унифицировано и все важные функциональности, например авторизация, находятся в пределах монолита, то у новой команды было нелегкое время при проектировании архитектуры.

Кроме того владельцы продукта хотят попробовать новую версию модуля Reviews с красными звездочками для Рождества. Они хотят протестировать этот функционал на небольшом сегменте пользователей, и если он понравится, то использовать его во всей системе.

Это невозможно без развертывания всего приложения в двух разных версиях. Это очень простое приложение с очень небольшим функционалом, а вы уже можете видеть количество проблем, с которыми мы столкнулись. А теперь подумайте об огромных приложениях, которые существуют уже несколько десятилетий и более.

Сотни и более разработчиков могут работать над этой системой. Начиная с неверных правил архитектуры, эта система может стать "big bowl of mud" - "большим комком грязи". Big bowl of mud - это известная идиома для такого типа ПО. Так незаметно ваше приложения может выйти из под контроля и стать одним из таких.

Давайте посмотрим как монолитное приложение "Book Info App" может чудесно и волшебно превратиться в микросервисы.

Если быть честным, это нелегкая задача отрефакторить монолитное приложение и делается не за одну ночь. Это культурные, технические и организационные усилия, которые прокладывают путь для трансформации приложения в cloud-native.

С новой микросервисной архитектурой каждый модуль является отдельным и независимым приложением.

Product Page было трансформировано в Python-приложение. Оно все еще функционирует в качестве landing-страницы.

Модуль Details был отрефакторен и превращен в Ruby-приложение.

Модуль Reviews был трансформирован в Java-приложение.

Модуль Ratings также был перепроектирован и реализован на NodeJS.

Более того модуль Review теперь имеет несколько версий - Version 1, Version 2, Version 3 для тестирования различных идей.

Version 1 - версия без звездочек, Version 2 - версия с черными звездочками, Version 3 - версия с красными звездочками.

Как и прежде пользователи попадают на страницу продукта, которая взаимодействует с сервисами Details и Reviews для отображения информации по различным продуктам.

<img src="screen3.png" width="800" height="400"><br>

Теперь, когда мы увидели как монолитное приложение было трансформировано в микросервисы, давайте поговорим об улучшениях и преимуществах.

Модуль Ratings больше не будет являться проблемой. Т.к. теперь он полностью независимый, мы легко можем масштабировать его в большую или меньшую сторону в зависимости от нагрузки, создаваемой пользователями.

Мы можем развернуть каждый кусок приложения "Book Info App" без влияния одного сервиса на другой. Это поможет сделать наши релизы меньше, быстрее и менее рискованными.

С микросервисной архитектурой компоненты могут быть написаны на различных языках программирования. Так в нашем приложения теперь используется четыре разных языка и команды получили автономию.

Наши сервисы изолированы от сбоев других сервисов из-за слабой взаимосвязи.

Конечное приложение будет более устойчиво, т.к. его компоненты могут быть поставлены на мониторинг, легко изменены или подвергнуты откату в случае необходимости.

Вместо одного большого приложения мы имеем шесть более маленьких. Поэтому надеемся, что теперь мы более не столкнемся с "big bowl of mud".

В идеальном сценарии микросервис должен иметь единую точку ответственности.

Ранее, когда мы обсуждали монолитное приложение "Book Info App", мы сказали, что кроме четырех модулей оно также "заботится" о сетевом взаимодействии, аутентификации, правилах авторизации, мониторинге, логировании, трассировке, каким образом данные передаются между модулями и т.д. Но что случится со всем этим при переходе на микросервисную модель? Наши микросервисы не обеспечивают ни одну из перечисленных функциональностей. Давайте добавим все эти функциональности в каждый из четырех сервисов.

<img src="screen4.png" width="800" height="400"><br>

Вероятно у вас уже есть идея к чему все идет. Теперь каждый микросервис обладает одинаковой функциональностью, написанной снова и снова (только на разных языках). Каждая команда вынуждена решать одни и те же проблемы и вероятно решает их по разному.

Посмотрите на код приложения. Каким образом вы собираетесь сообщить командам поменять сертификат или версию агента мониторинга? Любой developer, который разрабатывает какое-либо из этих приложений, должен быть в курсе обо всех этих дополнительных компонентах, и это помимо знания ключевой бизнес логики, которую должны обслуживать микросервисы. Эти проблемы, с которыми мы сталкиваемся в каждом микросервисе, называются "cross-cutting concerns" (сквозные проблемы). Включенные в код микросервиса, они нарушают главную концепцию выбора микросервисной архитектуры - возможность иметь небольшие независимые кусочки. Эта проблема известна под названием "жирные микросервисы".

Микросервисы - это не кусочки пирога. Они имеют свои собственные проблемы и обладают тенденцией становиться действительно сложными.

Как мы только что видели, в монолитной версии приложения такие аспекты как сетевое взаимодействие и безопасность включены непосредственно в приложение. Но теперь все эти "серые области", созданные в монолитном приложении, выставлены наружу, и мы нашли способ покрыть их.

Каким образом страница продукты должна понимать к какой версии модуля Reviews нужно обращаться? Как один сервис будет находить другой сервис? Какие правила для трафика? Какие таймауты?

Через очень короткое время у вас будет очень много небольших распределенных сервисов и ответить на эти вопросы станет еще сложнее.

Было намного легче поддерживать безопасность в монолите, т.к. он обеспечивал нам подходящую прослойку.

В микросервисах безопасность service-to-service и end-user-to-service взаимодействия может стать проблемой.

Теперь, когда у вас есть слабо связанные небольшие кусочки и множество слоев абстракции, становится тяжело выявить проблему в приложении. Поэтому вам потребуется observability (наблюдаемость) стратегия.

Даже для небольшого приложения мы использовали четыре разных языка. Со всеми этими различными технологиями микросервисов становится очень сложно выполнять традиционные задачи. На самом деле operations могут стать бутылочным горлышком для организаций использующих микросервисы.

Для этого существует новый подход под названием DevOps, при котором команды разработки тесно связаны с operations. И они вместе берут на себя ответственность за deploy, мониторинг и исправление своих микросервисов.