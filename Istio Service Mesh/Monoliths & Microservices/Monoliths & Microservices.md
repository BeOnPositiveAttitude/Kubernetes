Перед погружением в Service Mesh и Istio давайте посмотрим на эволюционные изменения в проектировании ПО за последние два десятилетия.

В 2000-х годах разработка ПО стала сильно ориентированной на процесс и медленной. Для некоторых индустрий, например для оборонки и авиации, это занимало почти 20 лет. Существовал огромный временной разрыв между необходимостью возникновения ПО и его окончательной доставкой. Бизнес успевал измениться еще до того, пока программные продукты были реализованы. Многие проекты были прекращены еще до их завершения. Было потрачено очень много денег. И владельцы бизнеса и IT-специалисты были расстроены.

В 2001-м году 17 независимых специалистов по программному обеспечению собрались вместе и опубликовали Agile манифест. Они рассказали миру, что имеющийся способ создания ПО имеет основные недостатки и нуждается в изменении.

Исходя из имеющегося у них опыта, они решили, что важнее:
- ценить людей и взаимодействие выше процессов и инструментов,
- работающее ПО, чем исчерпывающая документация,
- сотрудничество с клиентами, чем переговоры по контракту,
- реагирование на изменения, чем следование плану.

Основываясь на Agile практике, мы не только больше сотрудничаем с клиентами, но также развиваем наши бизнес-модели и ПО на основе реальных экспериментов.

Когда вы работаете над одним большим приложением, если что-то ломается, то ломается целиком.

Однако, если бы вы меняли небольшие кусочки приложения, то все было бы под контролем. Кусок, над которым вы экспериментируете, может быть затронут, но риск будет меньше, чем прежде.

Так мы начали проектировать приложения все более и более маленькими, чтобы была возможность изолировать риски в процессе экспериментов, а также для более быстрого и частого деплоя.

Гигантские системы, которые мы разрабатывали, становились одной большой проблемой на пути к инновациям и гибкости. Мы должны были взглянуть на традиционную архитектуру ПО и переработать ее.

Термин "монолитный" используется, когда весь функционал приложения необходимо разворачивать одновременно и существует единый подход ко всем отдельным функциональным возможностям в рамках монолитных границ. Все функциональности как правило используют единую кодовую базу и нет четких границ между ними. Эти кусочки тесно связаны. Весь код даже может работать как один процесс. В этой модели обычно используется единая БД для persistance, которая в определенный момент становится "бутылочным горлышком".

Давайте посмотрим как работает "монолит" в реальном приложении. Здесь представлено приложение "Book Info App". Мы будем использовать его в качестве примера в этом курсе. Оно состоит из четырех разных модулей - Details, Reviews, Ratings, Product Page. Это модульное приложение, но все еще монолитное. Все сервисы зависят от определенной версии друг друга. Вам нужно развернуть весь пакет и возможно выполнить несколько скриптов в БД.

<img src="screen1.png" width="400" height="500"><br>

Страница продукта отображает информацию о книгах, обзоры и рейтинги. Все данные приложения приходят из разных модулей. Но эти модули не спроектированы по отдельности и не могут быть масштабированы.

Давайте попробуем понять зависимости модулей и проблемы монолитного приложения "Book Info App". Клиент попадает на страницу продукта.

Страница продукта получает информацию от модулей Reviews и Details.

Сервис Reviews получает количество рейтингов от сервиса Ratings.

Все они написаны на одном и том же языке - Java.

Кроме этих модулей приложение также "заботится" о сетевом взаимодействии, аутентификации, правилах авторизации, мониторинге, логировании, трассировке, каким образом данные передаются между модулями и т.д.

<img src="screen2.png" width="600" height="500"><br>

Время от времени модуль Ratings из-за количества данных испытывает проблемы и это влияет на всю систему.

Невозможно масштабировать только модуль Ratings или убрать его из системы без вмешательства в код и переразвертывания приложения.

Сейчас разрабатывается новый модуль Campaign и под него была сформирована новая команда, которая хочет использовать другой язык при разработке.

Т.к. все унифицировано и все важные функциональности, например авторизация, находятся в пределах монолита, то у новой команды было нелегкое время при проектировании архитектуры.

Кроме того владельцы продукта хотят попробовать новую версию модуля Reviews с красными звездочками для Рождества. Они хотят протестировать этот функционал на небольшом сегменте пользователей, и если он понравится, то использовать его во всей системе.

Это невозможно без развертывания всего приложения в двух разных версиях. Это очень простое приложение с очень небольшим функционалом, а вы уже можете видеть количество проблем, с которыми мы столкнулись. А теперь подумайте об огромных приложениях, которые существуют уже несколько десятилетий и более.

Сотни и более разработчиков могут работать над этой системой. Начиная с неверных правил архитектуры, эта система может стать "big bowl of mud" - "большим комком грязи". Big bowl of mud - это известная идиома для такого типа ПО. Так незаметно ваше приложения может выйти из под контроля и стать одним из таких.

Давайте посмотрим как монолитное приложение "Book Info App" может чудесно и волшебно превратиться в микросервисы.

Если быть честным, это нелегкая задача отрефакторить монолитное приложение и делается не за одну ночь. Это культурные, технические и организационные усилия, которые прокладывают путь для трансформации приложения в cloud-native.

С новой микросервисной архитектурой каждый модуль является отдельным и независимым приложением.

Product Page было трансформировано в Python-приложение. Оно все еще функционирует в качестве landing-страницы.

Модуль Details был отрефакторен и превращен в Ruby-приложение.

Модуль Reviews был трансформирован в Java-приложение.

Модуль Ratings также был перепроектирован и реализован на NodeJS.

Более того модуль Review теперь имеет несколько версий - Version 1, Version 2, Version 3 для тестирования различных идей.

Version 1 - версия без звездочек, Version 2 - версия с черными звездочками, Version 3 - версия с красными звездочками.