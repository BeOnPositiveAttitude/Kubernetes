Сертификат используется, чтобы гарантировать доверие между двумя сторонами в процессе транзакции. Например, когда пользователь пытается получить доступ к веб-серверу, TLS-сертификат гарантирует, что взаимодействие между пользователем и сервером зашифровано, и сервер действительно является тем, за кого себя выдает.

Рассмотрим следующий сценарий. Если пользователь получает доступ к приложению для онлайн-банкинга без использования защищенного соединения, то учетные данные, которые он введет, будут переданы в обычном текстовом формате. Хакер, прослушивающий сетевой трафик, может легко извлечь учетные данные и использовать их для взлома банковского аккаунта. Очевидно, что это не безопасно.

Вы должны зашифровать передаваемые данные, используя ключи шифрования. Данные шифруются с помощью ключа, который по сути является набором случайных чисел и алфавита. Вы добавляете случайное число к данным и шифруете в формате, который не может быть распознан. Затем данные отправляется на сервер. Хакер, прослушивающий сетевой трафик, получает данные, но ничего не может с ними сделать. Однако то же самое происходит и с сервером, получившим данные. Он не может расшифровать данные без ключа. Копию ключа также должна быть отправлена на сервер, чтобы он смог расшифровать и прочитать сообщение. Т.к. ключ передается через ту же сеть, атакующий может извлечь и его, а затем расшифровать данные с его помощью. Это известно как *симметричное шифрование*. Это безопасный способ шифрования, но т.к. он использует один и тот же ключ для шифрования и дешифрования данных, и т.к. ключ необходимо передавать между отправителем и получателем, существует риск получения доступа к ключу хакером и дальнейшей расшифровки данных.

И здесь на помощь приходит *асимметричное шифрование*. Вместо использования единого ключа для шифрования и дешифрования данных, асимметричное шифрование использует пару ключей - приватный ключ и публичный ключ. Ради этого примере мы будем называть их приватный ключ и публичный замок.

<img src="image.png" width="400" height="100"><br>

Ключ (key), который только со мной, поэтому он приватный. Замок (lock), доступ к которому может получить каждый, поэтому он публичный. Хитрость здесь в том, что если вы зашифровали или заблокировали (lock) данные с помощью вашего замка (lock), то вы сможете открыть их только с помощью связанного ключа. Поэтому ваш ключ всегда должен быть в безопасности у вас и не должен передаваться никому другому. А вот замок публичный и им можно делиться с другими людьми, но с его помощью они смогут только заблокировать что-либо. Независимо от того, что было заблокировано с помощью публичного замка, оно может быть разблокировано только с помощью вашего приватного ключа.

Рассмотрим еще более простой случай обеспечения (securing) ssh-доступа к серверам через пару ключей. Есть сервер, к которому вам нужен доступ. Вы не хотите использовать пароли, т.к. это слишком рискованно, и решили использовать пару ключей. С помощью команды `ssh-keygen` вы генерируете пару ключей - приватный и публичный. Она создает два файла: `id_rsa` - приватный ключ, `id_rsa.pub` - публичный ключ (точнее не публичный ключ, а публичный замок). Затем вы защищаете ваш сервер путем полной блокировки доступа к нему, за исключением "двери", которая заблокирована вашим публичным замком. Обычно это делается путем добавления на сервер записи, содержащей ваш публичный ключ, в файл `~/.ssh/authorized_keys`. Как видите замок публичный и любой может попытаться прорваться через него. Но до тех пор пока никто не получит в свои руки ваш приватный ключ, который находится в безопасности на вашем лаптопе, никто не сможет получить доступ на сервер.

При попытке подключиться по ssh вы указываете местоположение приватного ключа: `ssh -i id_rsa user1@server1`.

Что если в вашем окружении есть и другие сервера? Как вы можете защитить более одного сервера с помощью пары ключей? Вы можете создать копии вашего публичного замка и положить их на множество серверов. Затем вы можете использовать тот же самый приватный ключ, чтобы безопасно подключаться по ssh к этим серверам.

Что если и другим пользователям нужен доступ к вашим серверам? Они могут сгенерировать свои собственные пары ключей, а вы, как единственный имеющий доступ к этим серверам, можете создать для этих людей дополнительные "двери" и заблокировать их с помощью соответствующих публичных замков. Скопируйте все публичные замки на сервера, и теперь другие люди смогут получить доступ к серверам с помощью их приватных ключей.

Вернемся к примеру с веб-сервером. Проблема симметричного шифрования заключается в том, что ключ, используемый для шифрования данных, передается на сервер через ту же сеть вместе с зашифрованными данными. Поэтому существует риск получения доступа к ключу хакером и дальнейшей расшифровки данных. Что если бы мы смогли каким-то образом безопасно передать ключ на сервер? Как только ключ будет безопасно передан и доступен для сервера, клиент и сервер смогут продолжить безопасно взаимодействовать друг с другом, используя симметричное шифрование.

Чтобы безопасно передать симметричный ключ от клиента к серверу, мы используем асимметричное шифрование. Мы генерируем приватный и публичный ключ на сервере. Теперь когда вы поняли идею, далее мы будем называть публичный замок публичным ключом. Ранее использовалась команда `ssh-keygen`, чтобы создать пару ключей для ssh-подключения. Формат немного отличается.

Здесь для генерации пары ключей мы используем команды:

```bash
openssl genrsa -out my-bank.key 1024
openssl rsa -in my-bank.key -pubout > mybank.pem
```

Когда пользователь первый раз обращается к веб-серверу по https, он получает с сервера публичный ключ. Предполагается, что хакер, слушающий весь трафик, также получит копию публичного ключа. Браузер пользователя шифрует симметричный ключ с помощью публичного ключа, предоставленного сервером. Симметричный ключ не безопасен. Затем пользователь посылает это (зашифрованный симметричный ключ) серверу. Хакер также получают копию. Сервер использует приватный ключ для дешифровки сообщения и извлекает из него симметричный ключ. Однако хакер в этой ситуации не имеет приватного ключа для расшифровки и извлечения симметричного ключа из полученного им сообщения. У него есть только публичный ключ, с помощью которого он может только заблокировать или зашифровать сообщение, но не дешифровать его. Теперь симметричный ключ безопасно доступен только серверу и пользователю, и они могут использовать его для шифрования данных и пересылки друг другу. Получатель может использовать тот же симметричный ключ для расшифровки данных и извлечения информации.

С помощью асимметричного шифрования мы успешно передали симметричный ключ от пользователя к серверу, а с помощью симметричного шифрования мы защитили все будущие взаимодействия между ними.

Теперь хакер ищет новые способы взлома аккаунта и осознает, что единственный способ получить ваши учетные данные - заставить вас ввести их в предоставленную им форму. Поэтому он создает веб-сайт, который выглядит в точности как веб-сайт банка. Хакер размещает этот сайт на собственном сервере. Он хочет, чтобы вы думали, что сайт безопасен. Поэтому злоумышленник генерирует приватный и публичный ключи и настраивает их на своем веб-сервере. И наконец ему удается каким-либо образом настроить ваше окружение (или сеть) для перенаправления запросов к веб-сайту банка на свои сервера.

Когда вы открываете браузер и вводите адрес веб-сайта, то видите очень привычную страницу, ту же самую страницу для логина, которую привыкли видеть. Вы вводите имя пользователя и пароль, убедившись, что ввели https-ссылку, что в свою очередь гарантирует, что взаимодействие безопасно зашифровано. Ваш браузер получает публичный ключ (злоумышленника), вы посылаете зашифрованный симметричный ключ, а затем и учетные данные, зашифрованные симметричным ключом. Получатель дешифрует учетные данные тем же симметричным ключом.

Вы безопасно взаимодействовали с сервером зашифрованным способом, но с сервером хакера.

Что, если бы у вас была возможность взглянуть на полученный от сервера ключ и посмотреть является ли он легитимным ключом от реального банковского сервера? Когда сервер отправляет ключ, он отправляет не только его. Он отправляет сертификат, который содержит ключ внутри. Если вы рассмотрите сертификат поближе, то увидите, что он похож на настоящий сертификат, но в цифровом формате. Он содержит информацию о том, кому выдан сертификат, публичный ключ этого сервера, местонахождение этого сервера и т.д. Справа вы видите содержимое настоящего сертификата. На каждом сертификате указано имя лица или субъекта, которому выдан сертификат. Это очень важно, т.к. это поле помогает подтвердить их личность.

<img src="image-1.png" width="900" height="400"><br>

Если это для веб-сервера, то данное поле должно совпадать с тем, что пользователь вводит в url браузера. Если банк известен под какими-либо другими именами и если он хочет, чтобы пользователи получали доступ к его приложениям также под другими именами, все эти имена должны быть указаны в сертификате в секции "Subject Alternative Name".

Но как вы могли заметить, кто угодно можно сгенерировать такой сертификат. Вы можете сгенерировать подобный для себя, сказав, что вы - Google. И это то, что делает хакер в таком случае. Он генерирует сертификат, говорящий, что он является веб-сайтом вашего банка.

Как вы можете посмотреть сертификат и проверить его подлинность? И вот где в игру вступает самая важная часть сертификата - кто подписал и выпустил сертификат. Если вы сгенерировали сертификат, тогда вам нужно будет самостоятельно его подписать. Это известно как *самоподписанный сертификат*. Любой посмотревший на сгенерированный вами сертификат немедленно узнает, что это небезопасный сертификат, т.к. подписали его вы. Если вы рассмотрите полученный от хакера сертификат поближе, то заметите, что это поддельный сертификат, подписанный самим хакером. Собственно говоря, браузер делает это за вас.

Все браузеры имеют встроенный механизм проверки сертификатов, где полученный от сервера сертификат проверяется на подлинность. Если браузер определяет, что сертификат поддельный, то он предупреждает вас об этом.