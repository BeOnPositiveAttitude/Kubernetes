Сертификат используется, чтобы гарантировать доверие между двумя сторонами в процессе транзакции. Например, когда пользователь пытается получить доступ к веб-серверу, TLS-сертификат гарантирует, что взаимодействие между пользователем и сервером зашифровано, и сервер действительно является тем, за кого себя выдает.

Рассмотрим следующий сценарий. Если пользователь получает доступ к приложению для онлайн-банкинга без использования защищенного соединения, то учетные данные, которые он введет, будут переданы в обычном текстовом формате. Хакер, прослушивающий сетевой трафик, может легко извлечь учетные данные и использовать их для взлома банковского аккаунта. Очевидно, что это не безопасно.

Вы должны зашифровать передаваемые данные, используя ключи шифрования. Данные шифруются с помощью ключа, который по сути является набором случайных чисел и алфавита. Вы добавляете случайное число к данным и шифруете в формате, который не может быть распознан. Затем данные отправляется на сервер. Хакер, прослушивающий сетевой трафик, получает данные, но ничего не может с ними сделать. Однако то же самое происходит и с сервером, получившим данные. Он не может расшифровать данные без ключа. Копию ключа также должна быть отправлена на сервер, чтобы он смог расшифровать и прочитать сообщение. Т.к. ключ передается через ту же сеть, атакующий может извлечь и его, а затем расшифровать данные с его помощью. Это известно как *симметричное шифрование*. Это безопасный способ шифрования, но т.к. он использует один и тот же ключ для шифрования и дешифрования данных, и т.к. ключ необходимо передавать между отправителем и получателем, существует риск получения доступа к ключу хакером и дальнейшей расшифровки данных.

И здесь на помощь приходит *асимметричное шифрование*. Вместо использования единого ключа для шифрования и дешифрования данных, асимметричное шифрование использует пару ключей - приватный ключ и публичный ключ. Ради этого примере мы будем называть их приватный ключ и публичный замок.

<img src="image.png" width="400" height="100"><br>

Ключ (key), который только со мной, поэтому он приватный. Замок (lock), доступ к которому может получить каждый, поэтому он публичный. Хитрость здесь в том, что если вы зашифровали или заблокировали (lock) данные с помощью вашего замка (lock), то вы сможете открыть их только с помощью связанного ключа. Поэтому ваш ключ всегда должен быть в безопасности у вас и не должен передаваться никому другому. А вот замок публичный и им можно делиться с другими людьми, но с его помощью они смогут только заблокировать что-либо. Независимо от того, что было заблокировано с помощью публичного замка, оно может быть разблокировано только с помощью вашего приватного ключа.

Рассмотрим еще более простой случай обеспечения (securing) ssh-доступа к серверам через пару ключей. Есть сервер, к которому вам нужен доступ. Вы не хотите использовать пароли, т.к. это слишком рискованно, и решили использовать пару ключей. С помощью команды `ssh-keygen` вы генерируете пару ключей - приватный и публичный. Она создает два файла: `id_rsa` - приватный ключ, `id_rsa.pub` - публичный ключ (точнее не публичный ключ, а публичный замок). Затем вы защищаете ваш сервер путем полной блокировки доступа к нему, за исключением "двери", которая заблокирована вашим публичным замком. Обычно это делается путем добавления на сервер записи, содержащей ваш публичный ключ, в файл `~/.ssh/authorized_keys`. Как видите замок публичный и любой может попытаться прорваться через него. Но до тех пор пока никто не получит в свои руки ваш приватный ключ, который находится в безопасности на вашем лаптопе, никто не сможет получить доступ на сервер.

При попытке подключиться по ssh вы указываете местоположение приватного ключа: `ssh -i id_rsa user1@server1`.

Что если в вашем окружении есть и другие сервера? Как вы можете защитить более одного сервера с помощью пары ключей? Вы можете создать копии вашего публичного замка и положить их на множество серверов. Затем вы можете использовать тот же самый приватный ключ, чтобы безопасно подключаться по ssh к этим серверам.

Что если и другим пользователям нужен доступ к вашим серверам? Они могут сгенерировать свои собственные пары ключей, а вы, как единственный имеющий доступ к этим серверам, можете создать для этих людей дополнительные "двери" и заблокировать их с помощью соответствующих публичных замков. Скопируйте все публичные замки на сервера, и теперь другие люди смогут получить доступ к серверам с помощью их приватных ключей.

Вернемся к примеру с веб-сервером. Проблема симметричного шифрования заключается в том, что ключ, используемый для шифрования данных, передается на сервер через ту же сеть вместе с зашифрованными данными. Поэтому существует риск получения доступа к ключу хакером и дальнейшей расшифровки данных. Что если бы мы смогли каким-то образом безопасно передать ключ на сервер? Как только ключ будет безопасно передан и доступен для сервера, клиент и сервер смогут продолжить безопасно взаимодействовать друг с другом, используя симметричное шифрование.

Чтобы безопасно передать симметричный ключ от клиента к серверу, мы используем асимметричное шифрование. Мы генерируем приватный и публичный ключ на сервере. Теперь когда вы поняли идею, далее мы будем называть публичный замок публичным ключом. Ранее использовалась команда `ssh-keygen`, чтобы создать пару ключей для ssh-подключения. Формат немного отличается.

Здесь для генерации пары ключей мы используем команды:

```bash
openssl genrsa -out my-bank.key 1024
openssl rsa -in my-bank.key -pubout > mybank.pem
```

Когда пользователь первый раз обращается к веб-серверу по https, он получает с сервера публичный ключ. Предполагается, что хакер, слушающий весь трафик, также получит копию публичного ключа. Браузер пользователя шифрует симметричный ключ с помощью публичного ключа, предоставленного сервером. Симметричный ключ не безопасен. Затем пользователь посылает это (зашифрованный симметричный ключ) серверу. Хакер также получают копию. Сервер использует приватный ключ для дешифровки сообщения и извлекает из него симметричный ключ. Однако хакер в этой ситуации не имеет приватного ключа для расшифровки и извлечения симметричного ключа из полученного им сообщения. У него есть только публичный ключ, с помощью которого он может только заблокировать или зашифровать сообщение, но не дешифровать его. Теперь симметричный ключ безопасно доступен только серверу и пользователю, и они могут использовать его для шифрования данных и пересылки друг другу. Получатель может использовать тот же симметричный ключ для расшифровки данных и извлечения информации.

С помощью асимметричного шифрования мы успешно передали симметричный ключ от пользователя к серверу, а с помощью симметричного шифрования мы защитили все будущие взаимодействия между ними.

Теперь хакер ищет новые способы взлома аккаунта и осознает, что единственный способ получить ваши учетные данные - заставить вас ввести их в предоставленную им форму. Поэтому он создает веб-сайт, который выглядит в точности как веб-сайт банка. Хакер размещает этот сайт на собственном сервере. Он хочет, чтобы вы думали, что сайт безопасен. Поэтому злоумышленник генерирует приватный и публичный ключи и настраивает их на своем веб-сервере. И наконец ему удается каким-либо образом настроить ваше окружение (или сеть) для перенаправления запросов к веб-сайту банка на свои сервера.

Когда вы открываете браузер и вводите адрес веб-сайта, то видите очень привычную страницу, ту же самую страницу для логина, которую привыкли видеть. Вы вводите имя пользователя и пароль, убедившись, что ввели https-ссылку, что в свою очередь гарантирует, что взаимодействие безопасно зашифровано. Ваш браузер получает публичный ключ (злоумышленника), вы посылаете зашифрованный симметричный ключ, а затем и учетные данные, зашифрованные симметричным ключом. Получатель дешифрует учетные данные тем же симметричным ключом.

Вы безопасно взаимодействовали с сервером зашифрованным способом, но с сервером хакера.

Что, если бы у вас была возможность взглянуть на полученный от сервера ключ и посмотреть является ли он легитимным ключом от реального банковского сервера? Когда сервер отправляет ключ, он отправляет не только его. Он отправляет сертификат, который содержит ключ внутри.