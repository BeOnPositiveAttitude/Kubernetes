Kubelet полагается на инструкции от kube-apiserver, чтобы понять какие pod-ы разместить на своей ноде. Эти инструкции в свою очередь основываются на решении принятом kube-scheduler-ом и сохраняются в хранилище etcd.

Но что если в кластере отсутствуют kube-apiserver, kube-scheduler, контроллеры и БД etcd? Что если вообще нет master-а? Что если нет других нод? Вы один в море. И не являетесь частью кластера. Может ли kubelet делать что-то как капитан корабля? Может ли он действовать как независимая нода? Если да, то кто будет предоставлять инструкции необходимые для создания pod-ов?

Kubelet может управлять нодой самостоятельно. Мы имеем установленные на хосте kubelet и Docker для запуска контейнеров. Нет кластера K8s, соответственно отсутствуют kube-apiserver и другие компоненты.

Единственное, что умеет делать kubelet - создавать pod-ы. Но у нас нет API-сервера, что предоставить детали для создания pod-ов. Мы знаем, чтобы создать pod, нужны подробности описанные в pod definition файле. Но как мы можем предоставить pod definition файл kubelet-у без kube-apiserver?

Вы можете сконфигурировать kubelet для чтения pod definition файлов из директории на сервере, предназначенной для хранения информации о pod-ах. Kubelet периодически проверяет эту директорию на наличие файлов, читает их и создает pod-ы на хосте. Но не только создает, а еще и гарантирует, что pod останется в живых. Если приложение упадет, kubelet попытается перезапустить его.

Если вы внесете изменения в какой-либо из файлов в этом каталоге, kubelet пересоздаст pod, чтобы изменения вступили в силу. Если вы удалите файл из директории, pod удалится автоматически.

Эти pod-ы, созданные kubelet самостоятельно без вмешательства kube-apiserver или остальных компонентов кластера K8s, известны как статические pod-ы.

Запомните, таким способом вы можете создать только pod-ы. Вы не можете создать Replica Set, Deployment или Service путем размещения definition файлов в назначенную директорию. Все они являются концептуальными частями всей архитектуры K8s, для которой требуются другие cluster plane компоненты, такие как replication-controller, deployment-controller и т.д.

Kubelet работает на уровне pod-ов и может понимать только pod-ы. Поэтому он имеет возможность создавать статические pod-ы.

Что за предназначенная директория и как мы можем ее настроить? Это может быть любая директория на хосте. Путь до этой директории передается kubelet в виде опции при запуске сервиса. Опция называется `--pod-manifest-path`.

<img src="image.png" width="600" height="150"><br>

Существует и другой способ настройки. Вместо задания опции прямо в файле `kubelet.service`, вы можете предоставить путь до другого конфигурационного файла с помощью опции `--config` и уже в нем определить путь до соответствующей директории с помощью опции `staticPodPath`.

<img src="image-1.png" width="800" height="200"><br>

Кластеры, созданные с помощью инструмента kubeadm, используют данный подход. Если вы исследуете существующий кластер, то нужно посмотреть эту опцию kubelet, чтобы определить путь до директории. Тогда вы поймете куда нужно положить definition файлы для ваших статических pod-ов.

Как только статические pod-ы создались, вы можете посмотреть их с помощью команды `docker ps`. Почему не с помощью команды `kubectl` как мы делали все это время? Помните, что у нас нет остальных компонентов кластера K8s, а утилита kubectl работает с kube-apiserver.

Как это работает, когда нода является частью кластера? Когда API-сервер отправляет запрос kubelet на создание pod-ов. Может ли kubelet создавать оба типа pod-ов одновременно? Kubelet может принимать запросы на создание pod-ов из разных inputs одновременно. Первый - через pod definition файлы из каталога для статических pod-ов. Второй - через HTTP API endpoint. Таким способом kube-apiserver предоставляет входные данные для kubelet.

Знает ли в этом случае API-сервер о статических pod-ах созданных kubelet? Да, знает. Если вы запустите команду `kubectl get pods` на master-ноде, статические pod-ы будут отображаться как и любые другие. Когда kubelet создает статический pod и сам является частью кластера, то он также создает зеркальный объект в kube-apiserver. То что вы видите от kube-apiserver является всего лишь read-only зеркалом pod-а. Вы можете посмотреть детали такого pod-а, но не можете отредактировать или удалить его как обычный pod. Вы можете только удалить его с помощью изменения файлов в каталоге манифестов на ноде.

К имени таких pod-ов автоматически добавляется название ноды.

Почему вы можете захотеть использовать подобные pod-ы? Так как статические pod-ы не зависят от K8s control plane, вы можете использовать их для деплоя самих компонентов control plane в виде pod-ов на ноде. Начните с установки kubelet на все master-ноды. Затем создайте pod definition файлы, использующие Docker-образы различных control plane компонентов, таких как kube-apiserver, controllers, etcd и т.д. Положите файлы манифестов в предназначенную для этого директорию. А kubelet позаботится о деплое самих control plane компонентов в виде pod-ов в кластере. При таком способе вам не нужно скачивать бинарные файлы, конфигурировать сервисы или беспокоиться о падении сервисов. В случае если какой-либо из сервисов упадет, т.к. это статический pod, он будет автоматически перезапущен kubelet. Таким способом утилита kubeadm устанавливает кластер. Поэтому когда вы смотрите pod-ы в namespace `kube-system`, то видите control plane компоненты в виде pod-ов.

Поговорим о различиях между Daemon Sets и статическими pod-ами.

Daemon Set гарантирует, что один экземпляр приложения всегда будет доступен на каждой ноде кластера. Он управляется с помощью DaemonSet Controller через kube-apiserver. Статические pod-ы, как мы узнали в этой лекции, создаются напрямую kubelet без какого-либо вмешательства kube-apiserver или других control plane компонентов K8s кластера. И статические pod-ы и pod-ы созданные с помощью Daemon Set игнорируются scheduler-ом.
