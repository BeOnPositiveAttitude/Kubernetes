Мы будем использовать аналогию с кораблями для понимания архитектуры K8s.

Мы имеем два типа кораблей в нашем примере.

*Грузовые суда* - выполняют реальную работу по перевозке контейнеров по морю.

*Управляющие суда* - отвечают за мониторинг и управление грузовыми судами.

K8s-кластер состоит из набора нод, которые могут быть физическими или виртуальными, on-premise или cloud, на которых размещаются приложения в форме контейнеров. В нашей аналогии это грузовые суда. Worker-ноды в кластере - это корабли способные загружать контейнеры.

Но кто-то должен загружать контейнеры на корабли. И не только загружать, но и планировать как загружать, идентифицировать правильные корабли, хранить информацию о кораблях, мониторить и отслеживать расположение контейнеров на кораблях, управлять всем процессом загрузки и т.д. Это делается управляющими судами, на которых размещаются различные офисы и отделы, оборудование для мониторинга и связи, краны для перемещения контейнеров между кораблями и т.д. Управляющие суда - это master-ноды в K8s-кластере. Master-нода отвечает за управление K8s-кластером, хранит информацию о различным узлах, планирует какие контейнеры куда вызывать, мониторит ноды и контейнеры на них и т.д. Master-нода делает все это с помощью набора компонентов, всех вместе известных как компоненты control plane.

Ежедневно множество контейнеров загружаются и выгружаются с кораблей. Поэтому вам нужно поддерживать актуальную информацию о различных кораблях - какой контейнер на каком корабле находится, в какое время контейнер был загружен и т.д. Все эта информация хранится в высоконадежном key-value хранилище известном как etcd. Etcd - это база данных, которая хранит данные в формате ключ-значение.

Когда корабли прибывают, вы загружаете на них контейнеры с помощью кранов. Краны идентифицируют контейнеры, которые нужно поместить на корабли. Они определяют подходящий корабль, основываясь на его размере, емкости, количестве контейнеров уже находящихся на нем и на разных других условиях, таких как пункт назначения корабля, тип контейнеров разрешенных к транспортировке и т.д. Это schedulers в K8s-кластере. Scheduler определяет подходящую ноду для размещения контейнера, основываясь на требованиях к ресурсам этого контейнера, емкости worker-ноды либо на других политиках и ограничениях, таких как taints & tolerations или node affinity rules.

В корабельном доке существует множество офисов или отделов, отведенных под специальные задачи. Например группа эксплуатации заботится об обслуживании судна, контроле движения и т.д. Они имеют дело с проблемами связанными с повреждениями судов и др. Грузовая команда заботится о контейнерах, когда контейнеры повреждаются или разрушаются они следят за тем, чтобы новые контейнеры были доступны. Офис обслуживания заботится об IT и связи между различными кораблями. Аналогично в K8s доступны контроллеры, которые заботятся о различных областях.

*Node-controller* заботится о нодах. Он отвечает за "посадку" новых нод в кластер, обработку ситуаций, когда ноды становятся недоступны или вовсе выходят из строя.

*Replication-controller* гарантирует, что всегда запущено желаемое количестве контейнеров в вашей replication group.

Мы рассмотрели различные компоненты, такие как офисы, корабли, краны, хранилище данных. Как они все взаимодействуют друг с другом? Как один офис может "достучаться" до другого и кто управляет всеми ими верхнеуровнево?

*Kube-apiserver* - основой компонент управления K8s. Kube-apiserver отвечает за оркестрирование всеми операциями в кластере. Он выставляет K8s API, который используется внешними пользователями для выполнения операций по управлению кластером, различными контроллерами для мониторинга состояния кластера и выполнения необходимых изменений, если таковые требуются, а также worker-нодами для взаимодействия с сервером.

Теперь мы работаем с контейнерами, они повсюду, поэтому нам нужно, чтобы все было совместимо с контейнерами. Наши приложения в форме контейнеров, различные компоненты, которые формируют всю управляющую систему на master-ноде могут быть размещены в виде контейнеров. DNS-сервис, сетевое решение могут быть развернуты в виде контейнеров. Поэтому нам нужно ПО, которое может запускать контейнеры и это *container runtime engine*. Одно из самых популярных - Docker. Соответственно нам нужен Docker или его эквивалент, установленный на всех нодах кластера, включая master-ноды, если вы хотите размещать компоненты control plane в виде контейнеров. Это не всегда будет Docker. K8s поддерживает и другие container runtime engine, такие как ContainerD или Rocket.

Давайте сфокусируемся на грузовых судах. У каждого корабля есть капитан. Капитан отвечает за управление всеми активностями на корабле, за связь с master-кораблями, начиная с оповещения master-корабля о заинтересованности вступить в группу, за получение информации о контейнерах, которые будут загружены на корабль, за загрузку соответствующих контейнеров по мере необходимости, за отправку отчетов обратно master-у о статусе этого корабля и о статусе контейнеров на нем и т.д. Капитан корабля это *kubelet* в K8s. Kubelet - это агент, который запускается на каждой ноде в кластере. Он слушает инструкции от kube-apiserver и разворачивает либо разрушает контейнеры на нодах по мере необходимости. Kube-apiserver периодически извлекает отчеты о состоянии из kubelet для мониторинга состояния нод и контейнеров на них.

Приложения развернутые на worker-нодах должны иметь возможность взаимодействовать друг с другом. Например у вас есть веб-сервер запущенный в контейнере на одной ноде и сервер БД запущенный в другом контейнере на другой ноде. Как веб-сервер сможет достучаться до сервера БД на другой ноде? Взаимодействие между worker-нодами обеспечивается другим компонентом, который запускается на worker-нодах и называется сервис *kube-proxy*. Сервис kube-proxy гарантирует, что необходимые правила находятся на месте на worker-нодах, чтобы запущенные на них контейнеры могли достучаться друг до друга.