Вернемся к началу эпохи контейнеров. Был Docker и были другие инструменты, такие как Rocket. Но пользовательский опыт использования Docker делал работу с контейнерами супер простой. Поэтому Docker стал самым доминирующим инструментом для работы с контейнерами.

Затем пришел K8s для оркестрирования Docker-ом. K8s был построен для оркестрирования конкретно Docker-ом в самом начале. Поэтому Docker и K8s были тесно связаны, и тогда K8s работал только с Docker-ом и не поддерживал какие-либо другие решения для управления контейнерами. Затем популярность K8s как оркестратора контейнеров выросла и сейчас хотелось бы видеть другие container runtimes, такие как Rocket. Пользователям K8s потребовалось работать с другими container runtimes кроме Docker.

K8s представил интерфейс, названный *Container Runtime Interface* (CRI). CRI позволяет любому вендору работать в качестве container runtime для K8s пока он (вендор) придерживается стандартов OCI. OCI расшифровывается как *Open Container Initiative* и состоит из спецификации образов (imagespec) и спецификации среды выполнения (runtimespec).

Imagespec означает спецификации того, каким образом должен собираться образ.

Runtimespec определяет стандарты того, каким образом container runtime должна разрабатываться. Таким образом, придерживаясь данных стандартов, любой может построить container runtime, которая может быть использована в дальнейшем кем угодно для работы с K8s.

Rocket и другие container runtimes, придерживавшиеся стандартов OCI, теперь поддерживаются в качестве container runtime в K8s через CRI.

Однако Docker НЕ был разработан с поддержкой стандартов CRI. Docker был разработан до введения CRI и все еще был самым доминирующим и используемым большинством инструментом для работы с контейнерами. Поэтому K8s продолжал также поддерживать Docker. K8s представил инструмент, известный как Docker Shim, который был замудренным, но временным способом продолжать поддерживать Docker за пределами Container Runtime Interface.

В то время как большинство других container runtimes работали через CRI, Docker продолжал работать без него. Теперь как видите Docker не является единственным container runtime. Docker состоит из множества инструментов, собранных вместе. Например Docker CLI, Docker API, build tool помогающая собирать образы. Была поддержка для Volumes, Auth, Security, а также наконец сама container runtime, которая называлась *runc* и демон, который управлял runc и назывался *containerd*.

containerd совместим с CRI и может работать напрямую с K8s как все другие runtimes. Таким образом containerd может использоваться самостоятельно в качестве runtime, отдельно от Docker. Сейчас мы имеем containerd как отдельную runtime и отдельно Docker.

K8s продолжал осуществлять поддержку движка Docker напрямую. Однако необходимость поддерживать Docker Shim была ненужным усилием и добавляла осложнений. В версии K8s 1.24 было решено полностью удалить Docker Shim. Таким образом поддержка Docker была удалена. Но все образы, которые были собраны до того, как Docker был удален, т.е. все Docker-образы, продолжают работать, т.к. Docker придерживался imagespec из стандартов OCI. Соответственно все образы собранные Docker соответствуют стандартам, они продолжают работать с containerd, но сам Docker был удален из K8s в качестве поддерживаемой runtime.

Не смотря на то, что containerd является частью Docker, сейчас это отдельный самостоятельный проект, являющийся членом CNCF, с graduated статусом.

Сейчас вы можете установить containerd самостоятельно без необходимости устанавливать Docker, если вам действительно не нужны функции Docker.

Обычно мы запускаем контейнеры с помощью команды `docker run`, когда у нас есть Docker. Но если Docker не установлен, как нам запускать контейнеры только с помощью containerd? Теперь когда вы устанавливаете containerd, он идет с утилитой командной строки *ctr*. Эта утилита создана исключительно для дебага containerd, соответственно она не user-friendly и поддерживает ограниченный набор функций. Это то, что вы увидите на страницах документации для этого инструмента.

Кроме ограниченного набора функций, который предоставляет данная утилита, любой другой способ взаимодействия с containerd предполагает использование прямых вызовов API, что не является самым user-friendly способом для нас. Просто чтобы дать вам представление, команда `ctr` может быть использована для выполнения базовых container-related активностей, таких как пуллинг образов.

Например, чтобы спуллить образ redis нужно использовать команду: `ctr images pull docker.io/library/redis:alpine`.

Для запуска контейнера: `ctr run docker.io/library/redis:alpine redis`.

Но как уже говорилось ранее эта утилита создана исключительно для дебага containerd, не очень user-friendly и НЕ используется для запуска или управления контейнерами в production окружении.

Рекомендуется использовать более подходящую альтернативу - утилиту *nerdctl*. Nerdctl - утилита командной строки очень похожая на Docker, это как CLI для containerd. Она поддерживает большинство опций, которые поддерживает Docker. Кроме этого она имеет дополнительную выгоду - она может дать нам доступ к новейшим функциям, реализованным в containerd. Например мы можем работать с зашифрованным образами контейнеров или другими новыми фичами, которые со временем будут реализованы в обычных Docker-командах в будущем. Она также поддерживает lazy pulling образов, P2P распространение образов, подпись и проверку образов, namespaces в K8s, которые недоступны в Docker.

Nerdctl работает очень схоже с Docker CLI. Вместо `docker` вы можете просто писать `nerdctl`.