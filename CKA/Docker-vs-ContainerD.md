Вернемся к началу эпохи контейнеров. Был Docker и были другие инструменты, такие как Rocket. Но пользовательский опыт использования Docker делал работу с контейнерами супер простой. Поэтому Docker стал самым доминирующим инструментом для работы с контейнерами.

Затем пришел K8s для оркестрирования Docker-ом. K8s был построен для оркестрирования конкретно Docker-ом в самом начале. Поэтому Docker и K8s были тесно связаны, и тогда K8s работал только с Docker-ом и не поддерживал какие-либо другие решения для управления контейнерами. Затем популярность K8s как оркестратора контейнеров выросла и сейчас хотелось бы видеть другие container runtimes, такие как Rocket. Пользователям K8s потребовалось работать с другими container runtimes кроме Docker.

K8s представил интерфейс, названный *Container Runtime Interface* (CRI). CRI позволяет любому вендору работать в качестве container runtime для K8s пока он (вендор) придерживается стандартов OCI. OCI расшифровывается как Open Container Initiative и состоит из спецификации образов (imagespec) и спецификации среды выполнения (runtimespec).

Imagespec означает спецификации того, каким образом должен собираться образ.

Runtimespec определяет стандарты того, каким образом container runtime должна разрабатываться.