Network Namespaces используются контейнерами, такими как Docker, для обеспечения сетевой изоляции.

Начнем с простого хоста. Как мы уже знаем, контейнеры отделены от основного хоста с помощью namespaces.

Что такое namespaces? Если представить, что хост - это дом, то namespace - это отдельная комната в доме, которую вы выделили каждому ребенку. Комнаты помогают обеспечить уединение для каждого ребенка. Каждый ребенок может видеть только то, что находится в его комнате и не может видеть, что происходит вне его комнаты. По их мнению, они единственные, кто живет в доме. Однако вы, как родитель, имеете обзор во все комнаты, а также и в другие пространства дома. Если вы захотите, то сможете установить соединение между двумя комнатами в доме.

Когда вы создаете контейнер, то хотите убедиться, что он изолирован и не видит каких-либо процессов хоста или другого контейнера. Поэтому мы создаем для него специальную "комнату" на хосте с помощью namespace.

Что касается контейнера, то он видит только запущенные им процессы и думает, что находится на своем собственном хосте. Однако основной хост видит вообще все процессы, включая процессы, запущенные внутри контейнеров. Когда вы делаете листинг процессов в контейнере, то видите один единственный процесс с PID равным 1. Когда вы делаете листинг тех же процессов на основном хосте из под пользователя root, то видите вообще все процессы, включая процесс запущенный в контейнере, но в этот раз уже с другим PID. Это один и тот же процесс, но с разным PID внутри и во вне контейнера.

<img src="image.png" width="800" height="300"><br>

Наш хост имеет свои собственные интерфейсы, подключенные к локальной сети, а также свои собственные таблицу маршрутизации и таблицу ARP, содержащие информацию об остальной части сети. Мы хотим "запечатать" (seal) всю эту информацию от контейнера. Когда контейнер создается, мы создаем для него network namespace. Таким образом он не видит какой-либо network-related информации на хосте.

В пределах namespace контейнер может иметь свои собственные виртуальные интерфейсы, таблицу маршрутизации и таблицу ARP.

Чтобы создать новый network namespace на Linux-хосте используйте команду: `ip netns add red`. Создадим второй namespace: `ip netns add blue`.

Для просмотра созданных network namespace используйте команду: `ip netns`.

Для листинга интерфейсов на хосте мы используем команду: `ip link`. Как посмотреть то же самое, но внутри созданного нами network namespace?

Для этого используйте команду: `ip netns exec red ip link` либо `ip -n red link`. В выводе присутствует только `loopback` интерфейс, при этом не видно интерфейс основного хоста `eth0`.

<img src="image-1.png" width="800" height="300"><br>

С помощью namespaces мы успешно ограничили контейнеру видимость интерфейса основного хоста. То же справедливо и для таблицы ARP. Если мы выполним команду `arp` на хосте, то увидим список записей. Если же мы запустим эту команду внутри контейнера - `ip netns exec red arp`, то не увидим никаких записей.

<img src="image-2.png" width="600" height="200"><br>

Аналогично для таблицы маршрутизации.

<img src="image-3.png" width="600" height="200"><br>

На текущий момент эти network namespaces не имеют сетевой связности. У них нет собственных интерфейсов и они не могут видеть сеть основного хоста.

Для начала рассмотрим настройку связности между самими namespace. Также как мы соединяем две физические машины вместе с помощью кабеля, подключая его к сетевому интерфейсу на каждой из машин, мы можем соединить два namespace вместе с помощью виртуальной ethernet-пары или виртуального кабеля. Часто он упоминается как pipe, но мы будем называть его виртуальным кабелем с двумя интерфейсами на обоих концах.

Для создания "кабеля" выполняем команду: `ip link add veth-red type veth peer name veth-blue`. Здесь `veth-red` и `veth-blue` это два конца виртуального кабеля.

Следующий шаг - подключить каждый интерфейс кабеля в соответствующий namespace.

```bash
ip link set veth-red netns red
ip link set veth-blue netns blue
```

Затем мы можем назначить IP-адрес каждому namespace. Обязательно задаем маску подсети, иначе, если делать как в уроке без указания маски, будет принята маска по умолчанию `/32` и связности не будет!

```bash
ip -n red addr add 192.168.15.1/24 dev veth-red
ip -n blue addr add 192.168.15.2/24 dev veth-blue
```

Включаем интерфейсы.

```bash
ip -n red link set veth-red up
ip -n blue link set veth-blue up
```

Теперь namespaces могут достучаться друг до друга. Проверяем - `ip netns exec red ping 192.168.15.2`. Пинг должен идти.

Если мы посмотрим таблицу ARP для namespace `red`, то увидим, что он идентифицировал своего "синего" соседа. Аналогично для namespace `blue`.

Если же мы посмотрим таблицу ARP самого хоста, то увидим, что он ничего не знает о созданных нами namespace-ах и о созданных внутри них интерфейсах.

<img src="image-4.png" width="600" height="400"><br>

Это работает в случае, когда у нас только два namespace. Но что делать, когда их больше? Как заставить их всех взаимодействовать друг с другом? Точно так же, как в физическом мире, вы создаете виртуальную сеть внутри хоста. Чтобы создать сеть, вам нужен коммутатор. Соответственно, чтобы создать виртуальную сеть, вам нужен виртуальный коммутатор. Вы создаете виртуальный свитч внутри хоста и подключаете namespace к нему. Как же нам создать этот виртуальный коммутатор внутри хоста? Существуют различные решения, например native solution под названием *Linux Bridge*, *Open vSwitch* и т.д. В данном примере мы будем использовать Linux Bridge.

Для создания внутренней bridge-сети, мы добавляем новый интерфейс на наш хост: `ip link add v-net-0 type bridge`. Что касается нашего хоста, то для него это всего лишь другой интерфейс, как например `eth0`.

Включим созданный интерфейс: `ip link set dev v-net-0 up`.

Для namespace-ов этот интерфейс похож на коммутатор, к которому они могут подключиться. Рассматривайте его как интерфейс для хоста и коммутатор для namespace-ов.

Следующий шаг - подключить namespaces к новому виртуальному коммутатору. Ранее мы создали "кабель" или ethernet-пару с интерфейсом `veth-red` на одному конце и `veth-blue` на другом, т.к. хотели соединить два namespace напрямую. Теперь же мы будем подключать все namespaces к bridge-сети. Для этого нам нужен новый "кабель", а от старого мы избавимся.

Используем команду: `ip -n red link delete veth-red`. Когда мы удаляем линк (veth-red) на одном конце кабеля, другой линк (veth-blue) удаляется автоматически, т.к. это пара.

Теперь создадим новые "кабели" для подключения namespaces к bridge. Интерфейсы `veth-red-br` и `veth-blue-br` подключаются на стороне bridge.

```bash
ip link add veth-red type veth peer name veth-red-br
ip link add veth-blue type veth peer name veth-blue-br
```

Подключим один конец "кабелей" к namespaces.

```bash
ip link set veth-red netns red
ip link set veth-blue netns blue
```

Другой конец к bridge.

```bash
ip link set veth-red-br master v-net-0
ip link set veth-blue-br master v-net-0
```

Назначим IP-адреса на интерфейсы:

```bash
ip -n red addr add 192.168.15.1/24 dev veth-red
ip -n blue addr add 192.168.15.2/24 dev veth-blue
```

Включаем интерфейсы.

```bash
ip -n red link set veth-red up
ip -n blue link set veth-blue up
```