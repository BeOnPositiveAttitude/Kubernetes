Helm имеет множество компонентов, с которыми мы будем работать. У нас есть утилита командной строки Helm, установленная на локальном компьютере, которую мы используем для различных Helm-actions, например для установки Charts, обновления, rollback и т.д. Charts - это коллекция файлов. Они содержат все необходимые инструкции, которые нужны Helm для создания объектов в K8s-кластере. С помощью Charts и путем добавления K8s-объектов, согласно определенным в этих Charts инструкциям, Helm устанавливает приложения в наш кластер. Когда Chart применен в кластере, создается Release. Release - одиночная инсталляция приложения с помощью Helm Chart. В рамках каждого Release может существовать несколько Revisions. Каждая Revision похожа на snapshot нашего приложения. Каждый раз когда происходит какое-либо изменения в нашем приложении, например обновление образа, изменение числа реплик или конфигурации объектов, создается новая Revision.

Аналогично поиску образов в Docker Hub, мы можем искать Helm Charts в публичных репозиториях. Мы можем легко скачать публично доступные Charts для различных приложений и использовать их для деплоя этих приложений в нашем кластере. Для отслеживания действий в нашем кластере, таких как установленные Releases, использованные Charts, состояние Revisions и др. Helm требуется место для хранения этих данных. Эти данные называются метаданными - данные о данных. Будет не очень полезно, если Helm будет хранить их на нашем локальном компьютере, т.к. если другому пользователю потребуется поработать с нашими Releases с помощью Helm, ему понадобится копия этих данных. Вместо этого Helm сохраняет эти метаданные напрямую в K8s-кластере в формате Secrets. Таким образом данные "выживают" и пока "живет" наш K8s-кластер каждый сотрудник нашей команды может получить к нему доступ и выполнить например обновление с помощью Helm или что-либо еще. Helm всегда будет знать обо всем, что вы сделали в кластере и будет иметь возможность отслеживать каждый шаг, каждое действие, т.к. метаданные всегда доступны.

Мы будем использовать два приложение в этом курсе для объяснения основных концепций. Первое - простое "Hello World!" приложение, которое состоит из простого Nginx веб-сервера и Service для публикации наружу. Второе - сайт на WordPress, которое будет немного сложнее.

"Hello World!" приложение состоит из двух объектов - Deployment и Service, а также файла values.yaml. Значения полей `replicas` и `image` в файле deployment.yaml заданы не в стандартном для K8s виде. Это называется шаблонизированием. Указанные в этих полях значения являются частью файла values.yaml. В Helm Charts мы часто будем взаимодействовать с этим специальным файлом. Большую часть времени нам не нужно создавать Charts самостоятельно, т.к. сотни Charts уже доступны для скачивания в публичных репозиториях. Но нам всегда нужно будет конфигурировать пакет, который мы установили с помощью Helm Chart. Файл values.yaml хранит изменяемые значения переменных. Большую часть времени нам нужно будет редактировать только этот файл для изменения конфигурации Deployment нашего приложения. Это как файл настроек или input-файл для Helm Charts.

Chart для WordPress более сложный, содержит множество файлов и сложное шаблонизирование. Он будет рассмотрен немного позже в этом курсе.

Когда Chart применен к нашему кластеру и создался Release, мы должны спросить себя - зачем нам требуется дополнительный item? Почему мы не можем сказать - мы установили Chart в K8s-кластер? Используя команду: `helm install my-site bitnami/wordpress` мы используем Chart `bitnami/wordpress` и имя Release `my-site`. Почему мы не можем просто выполнить команду: `helm install bitnami/wordpress` без указания имени Release? Самая простая причина почему нужно указывать Release - это возможность установки нескольких Releases на основе одного и того же Chart. То есть мы можем развернуть второй сайт командой: `helm install my-SECOND-site bitnami/wordpress` и у нас будет два разных Release, которые можно изменять независимо друг от друга. Хоть они и базируется на одном и том же Chart, но фактически являются двумя разными сущностями. Это может быть полезно во множестве сценариев. У нас может быть сайт на WP, который использует заказчик и другой сайт на WP, который использует внутренняя команда разработки. Они могут экспериментировать и добавлять новые фичи без "ломания" основного сайта. 