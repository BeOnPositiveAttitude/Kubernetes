Между 2-й и 3-й версией Helm имеются существенные различия.

Helm имеет в составе cli-утилиту, устанавливаемую на локальный компьютер, которая позволяет выполнять Helm-specific действия в K8s-кластере. Когда вышла версия Helm 2.0, K8s еще не имел таких "фишек", как например RBAC и CRD. Для того, чтобы позволить Helm делать свою "магию", нужно было установить дополнительный компонент Tiller в наш K8s-кластер. То есть когда мы хотели выполнить какую-либо Helm-specific команду, Helm-клиент взаимодействовал с Tiller, который был запущен на каком-либо сервере, а Tiller в свою очередь взаимодействовал с K8s-кластером. Проще говоря, Tiller был своего рода посредником.

Кроме того, что дополнительный компонент, находящийся между вами и K8s-кластером, добавлял сложности, имелись также проблемы в безопасности. По умолчанию Tiller запускался в режиме god-mode, то есть имел полные привилегии в кластере. С одной стороны это было хорошо, т.к. позволяло выполнять необходимые действия для установки наших Charts, но плохо с другой стороны, т.к. любой пользователь с Tiller мог получить полный доступ к кластеру.

Когда в K8s появились такие фичи, как RBAC и CRD, необходимость в Tiller начала снижаться и он был удален в версии Helm 3. Теперь не существует никаких посредников между нами и K8s-кластером. Более того, с введением RBAC безопасность сильно улучшилась и любой пользователь может быть ограничен в своих правах на Helm-операции. Раньше приходилось устанавливать эти ограничения в Tiller и это был не лучший вариант. С появлением RBAC, созданным с нуля для точной настройки прав пользователей в K8s, теперь это сделать просто. Что касается K8s, не имеет значения пытается ли пользователь выполнить изменения в кластере с помощью команды kubectl или с помощью Helm-команд. Пользователь, посылающий запрос на изменение, имеет те же RBAC права независимо от используемой утилиты.

Второе важно отличие - 3-Way Strategic Merge Patch. Helm имеет нечто похожее на snapshot feature. Например мы можем использовать Chart для установки полноценного WordPress-сайта: `helm install wordpress`. Будет создана Revision №1 для этой инсталляции. Далее мы обновились до более новой версии Chart для апгрейда нашего приложения: `helm upgrade wordpress`, и получили Revision №2. Эти ревизии могут рассматриваться как snapshot-ы - точное состояние приложения в K8s в определенный момент времени. В случае необходимости мы можем откатиться на Revision №1: `helm rollback wordpress`. Новые ревизии создаются каждый раз, когда вносятся важные изменения с помощью Helm-команд. В нашем примере при rollback также будет создана новая Revision №3. Helm 2 был менее "искушенным", когда дело доходило до rollbacks. Когда выполнялась команда `rollback`, Helm сравнивал текущий Chart (версия образа wordpress:5.8) с предыдущим Chart (версия образа wordpress:4.8), понимал что есть отличия, и откатывал WP к версии 4.8.

Рассмотрим другой пример. Мы развернули Deployment с WordPress командой `helm install wordpress`, которая создала Revision №1. Далее пришел пользователь и обновил image командой: `kubectl set image wordpress wordpress:5.8-apache`, то есть образ обновился, но без использования Helm. Соответственно не создалась новая ревизия. Если мы выполним команду `helm rollback wordpress`, что произойдет? Как и прежде Helm сравнит текущую ревизию с предыдущей версией, а т.к. ревизия только одна, он не увидит изменений и не выполнит rollback. Helm 2 сравнивает текущий Chart с предыдущим Chart на предмет различий для принятия дальнейшего решения о выполнении rollback. В нашем случае это не поможет, т.к. ручное изменение сделанное пользователем все еще активно.

Helm 3 в свою очередь более интеллектуальный. Он сравнивает текущий Chart, ревизию для которого мы не сделали, с Chart на который мы хотим откатиться, а также live state - как наши объекты K8s выглядят на текущий момент, их описания в YAML-формате. И здесь на сцену выходит 3-Way Strategic Merge Patch. Рассматривая также live state, он увидит что в реальности версия образа `wordpress:5.8-apache`, а версия образа в Revision №1, на которую мы хотим откатиться, равна `wordpress:4.8-apache`. Helm сделает необходимые изменения для возврата к исходному состоянию.

Помимо rollbacks Helm 2 также проигрывает в обновлениях. Например мы установили Chart, затем сделали некоторые изменения в объектах K8s. Все работает хорошо, пока дело не дойдет до обновления. Helm 2 смотрит на старый Chart, затем на новый Chart, на который мы хотим обновиться, и все ручные изменения будут утеряны, т.к. их нет ни в старом ни в новом Chart. Helm 3 же смотрит на Chart-ы и на live state и заметит, что вы сделали изменения вручную и сохранит эти изменения при обновлении.