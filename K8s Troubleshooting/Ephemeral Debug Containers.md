`kubectl debug` позволяет подключить контейнер к существующему запущенному pod-у.

Вы разумеется можете подумать "зачем использовать `kubectl debug`, если я могу подключиться к контейнеру в pod-е напрямую с помощью `kubectl exec` и выполнять команды прямо в нем"?

Первая причина - **минимизировать сбои** pod-ов в production-окружении. Представим, что у нас есть pod, в котором мы начали выполнять различные debug-команды и случайно запустили команду, которая "вмешалась" в процесс, обслуживающий production трафик. С помощью `kubectl debug` мы можем подключить контейнер к существующему контейнеру без влияния на запущенную нагрузку.

Вторая причина - когда у нас есть **distroless-образы**, запущенные в pod-ах. Distroless-образы - это максимально "голые" образы, которые имеют на борту только те зависимости, которые требуются непосредственно для работы приложения. Такие образы могут вовсе не иметь какого-либо shell и соответственно каких-либо инструментов для траблшутинга. Причина использования distroless-образов - это хорошая security practice, т.к. минимизируется поверхность атаки (attack surface). Также это улучшает производительность, т.к. образы намного меньше по размеру.

Третья причина - когда у нас есть **"падающие" контейнеры** и мы не успеваем подключиться к ним с помощью `kubectl exec`.

Кроме того `kubectl debug` можно использовать для дебага чего-либо на нодах.

```shell
$ kubectl debug distroless-pod -it --image=busybox
```

Здесь `distroless-pod` - название pod-а, который нам нужно дебажить, `busybox` - имя образа, содержащего необходимые нам для дебага инструменты. Debug-контейнер получит название `debugger-xxxxx`.

При выходе из debug-контейнера мы получим сообщение:

```shell
Session ended, the ephemeral container will not be restarted but may be reattached using 'kubectl attach distroless-pod -c debugger-25snh -i -t' if it is still running
```

Т.е. при необходимости мы сможем к нему переподключиться.

С помощью опции `--target` мы можем указать debug-контейнеру process namespace целевого контейнера, который мы хотим дебажить. Таким образом главный контейнер и debug-контейнер будут разделять process namespace.