Как мы узнали из прошлого урока одна API Group может одновременно поддерживать несколько версий API. Зачем вам нужно поддерживать несколько версий? Как много версий вам нужно поддерживать? Когда вы можете удалить старую версию, если она больше не нужна? Ответ на эти вопросы дает API Deprecation Policy.

Рассмотрим жизненный цикл API Group. Допустим мы планируем делать вклад в проект K8s и создаем API Group `/kodekloud.com`, внутри которой будут два resource - `/course` и `/webinar`. Мы все протестировали и готовы мерджить в проект K8s, выпускается alpha-версия с именем `v1alpha1`. Теперь мы можем создать например объект Course:

```yaml
apiVersion: kodekloud.com/v1alpha1
kind: Course
metadata:
  name: ckad
spec:
```
Предположим, что объект Webinar не понравился пользователям и мы решили его удалить в следующем релизе K8s. Можем ли мы только удалить его из версии v1alpha1? Нет. И это первое правило API Deprecation Policy - *API elements may only be removed by incrementing the version of the API group*. Это означает, что мы можем удалить элемент Webinar из версии v1alpha2 API Group. При этом он продолжит существовать в версии v1alpha1.

```yaml
apiVersion: kodekloud.com/v1alpha2
kind: Course
metadata:
  name: ckad
spec:
```
При этом уже созданный ресурс в базе данных кластера все еще будет оставаться версии v1alpha1, а версия API у нас изменилась на v1alpha2. Это могло бы стать проблемой, ведь мы должны пройтись по всем yaml-файлам и изменить версию API на v1alpha2. Вот почему новый релиз должен поддерживать обе версии - v1alpha1 и v1alpha2, при этом preferred или storage версия может быть v1alpha2. Это значит, что пользователи могут использовать те же самые yaml-файлы для создания ресурсов, но они будут автоматически сконвертированы и сохранены в версии v1alpha2.

И мы плавно подошли ко второму правилу API Deprecation Policy - *API objects must be able to round-trip between API versions in a given release without information loss, with the exception of whole REST resources that do not exist in some versions*. То есть, если мы создали объект в версии v1alpha1 и он был сконвертирован в v1alpha2 и затем обратно в v1alpha1, он должен остаться таким же как оригинальный объект версии v1alpha1.

Например объект Course в версии v1alpha1 в секции `spec` имеет параметр `type: video`. Затем он был сконвертирован в версию v1alpha2, где появился дополнительный параметр `duration:`, которого не было в версии v1alpha1. Когда мы сконвертируем объект обратно в версию v1alpha1, он будет иметь новый параметр, которого не было в оригинальной версии v1alpha1. Поэтому мы должны добавить поле `duration:` и в оригинальную версию v1alpha1, чтобы объект сконвертированный в v1alpha1 был идентичен объекту в оригинальной версии v1alpha1.

<img src="rule2.png" width="1000" height="200"><br>

Продолжая нашу историю, мы исправили множество багов и готовы к beta-релизу. Наша первая beta-версия готова называется v1beta1. Спустя несколько месяцев мы выпустили версию v1beta2. И в итоге представили финальную GA stable версию под названием v1.

Однако нам необязательно держать все имеющиеся версии доступными все время. Мы должны выводить и удалять старые версии по мере введения новых.