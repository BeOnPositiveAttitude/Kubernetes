Когда нам нужно создать например такой Deployment из definition-файла:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      type: front-end
  template:
    metadata:
      name: myapp-pod
      labels:
        type: front-end
    spec:
      containers:
      - image: nginx
```
K8s создает этот Deployment и сохраняет информацию в etcd. После мы можем выполнить команду get или delete над созданным Deployment. Все эти операции просто создают, получают информацию, изменяют или удаляют объект Deployment в etcd. Когда мы создаем Deployment он создает некоторое число pod-ов равное числу реплик, в нашем примере 3. Кто или что отвечает за этот процесс? Это работа контроллера, в нашем случае Deployment Controller-а. Мы не создавали этот Deployment Controller, т.к. он является встроенным в K8s "из коробки" и сразу доступен. Контроллер - это процесс запущенный в background и его работа состоит в непрерывном мониторинге статуса ресурсов, которыми он призван управлять, в нашем случае Deployment. Соответственно когда мы создаем, изменяем или удаляем Deployment, контроллер выполняет необходимые изменения в кластере для соответствия тому, что мы изменили. В нашем случае когда мы создали Deployment, контроллер создал ReplicaSet, которая в свою очередь создала указанное количество pod-ов.

Deployment Controller написан на языке Go и является частью исходного кода K8s.

Все объекты в K8s имеют свои контроллеры, которые следят за состоянием этих объектов и выполняют соответствующие изменения в кластере в случае необходимости.

Предположим мы хотим создать новый объект FlightTicket в K8s для бронирования авиабилетов:
```yaml
apiVersion: flights.com/v1
kind: FlightTicket
metadata:
  name: my-flight-ticket
spec:
  from: Mumbai
  to: London
  number: 2
```
Мы хотим, чтобы была возможность создавать указанный ресурс, получать список и удалять. Ресурс будет создаваться в etcd, но на самом деле бронирования авиабилетов происходить не будет, верно? Мы же хотим на самом деле бронировать реальные авиабилеты. Допустим существует API https://book-flight.com/api, который мы можем вызывать для бронирования авиабилетов. Каким образом мы можем вызывать этот API каждый раз когда создаем объект FlightTicket? Для этого нам нужен контроллер. Мы создадим FlightTicket Controller написанный на Go и он будет следить за созданием, изменением или удалением ресурса FlightTicket. Когда мы будем создавать объект FlightTicket, контроллер будет вызывать API https://book-flight.com/api для бронирования авиабилетов, когда будем удалять объект FlightTicket, контроллер будет вызывать API для отмены бронирования авиабилетов.

Созданный нами объект FlightTicket является custom resource, а FlightTicket Controller, написанный для вызова API https://book-flight.com/api является custom controller. По умолчанию мы не можем просто взять и создать этот новый объект, т.к. получим ошибку. Каким образом мы должны действовать? Для этого нам потребуется Custom Resource Definition (CRD). Мы будем использовать CRD, чтобы сообщить K8s, что мы хотим создавать объекты типа FlightTicket. CRD - это тоже объект с секциями apiVersion, kind, metadata, spec. Пример в файле flightticket-custom-definition.yaml. После этого мы сможем создавать объекты FlightTicket. Но это будут всего лишь ресурсы хранящиеся в etcd. То есть недостаточно создать только CRD, необходимо еще создать custom controller для этого объекта.